{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `chrono`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":5676,"byte_end":5682,"line_start":189,"line_end":189,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"    let timestamp = chrono::Utc::now().format(\"%Y-%m-%d %H:%M\").to_string();","highlight_start":21,"highlight_end":27}],"label":"use of unresolved module or unlinked crate `chrono`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `chrono`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:189:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mmp = chrono::Utc::no\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `chrono`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AnalysisMode` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/analyzer.rs","byte_start":3999,"byte_end":4011,"line_start":70,"line_end":70,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn get_prompt(mode: &AnalysisMode) -> &'static str {","highlight_start":30,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"src/analyzer.rs","byte_start":1024,"byte_end":1024,"line_start":36,"line_end":36,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    pub const DEBATE: &str = r#\"","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use crate::database::AnalysisMode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find type `AnalysisMode` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/analyzer.rs:70:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m: &AnalysisMode) -> &\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse crate::database::AnalysisMode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `AnalysisMode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/analyzer.rs","byte_start":4064,"byte_end":4076,"line_start":72,"line_end":72,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"            AnalysisMode::Debate => DEBATE,","highlight_start":13,"highlight_end":25}],"label":"use of undeclared type `AnalysisMode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"src/analyzer.rs","byte_start":1024,"byte_end":1024,"line_start":36,"line_end":36,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    pub const DEBATE: &str = r#\"","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use crate::database::AnalysisMode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `AnalysisMode`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/analyzer.rs:72:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   AnalysisMode::Deba\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `AnalysisMode`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse crate::database::AnalysisMode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `AnalysisMode`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/analyzer.rs","byte_start":4108,"byte_end":4120,"line_start":73,"line_end":73,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"            AnalysisMode::Summary => SUMMARY,","highlight_start":13,"highlight_end":25}],"label":"use of undeclared type `AnalysisMode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"src/analyzer.rs","byte_start":1024,"byte_end":1024,"line_start":36,"line_end":36,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    pub const DEBATE: &str = r#\"","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use crate::database::AnalysisMode;\n\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `AnalysisMode`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/analyzer.rs:73:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   AnalysisMode::Summ\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `AnalysisMode`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse crate::database::AnalysisMode;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `debug`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/analyzer.rs","byte_start":404,"byte_end":409,"line_start":15,"line_end":15,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":15,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/analyzer.rs","byte_start":404,"byte_end":411,"line_start":15,"line_end":15,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `debug`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/analyzer.rs:15:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use tracing::{debug, err\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `parking_lot::RwLock`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/recorder.rs","byte_start":147,"byte_end":166,"line_start":6,"line_end":6,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use parking_lot::RwLock;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/audio/recorder.rs","byte_start":143,"byte_end":168,"line_start":6,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use parking_lot::RwLock;","highlight_start":1,"highlight_end":25},{"text":"use serenity::model::id::UserId;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `parking_lot::RwLock`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/audio/recorder.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use parking_lot::RwLock;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::sync::Arc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/recorder.rs","byte_start":362,"byte_end":376,"line_start":13,"line_end":13,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/audio/recorder.rs","byte_start":358,"byte_end":378,"line_start":13,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":20},{"text":"use std::time::{SystemTime, UNIX_EPOCH};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::sync::Arc`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/audio/recorder.rs:13:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::sync::Arc;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `warn`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/recorder.rs","byte_start":475,"byte_end":479,"line_start":16,"line_end":16,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":35,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/audio/recorder.rs","byte_start":473,"byte_end":479,"line_start":16,"line_end":16,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":33,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `warn`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/audio/recorder.rs:16:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m, info, warn};\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `info`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/processor.rs","byte_start":205,"byte_end":209,"line_start":8,"line_end":8,"column_start":22,"column_end":26,"is_primary":true,"text":[{"text":"use tracing::{debug, info, warn};","highlight_start":22,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/audio/processor.rs","byte_start":203,"byte_end":209,"line_start":8,"line_end":8,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"use tracing::{debug, info, warn};","highlight_start":20,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `info`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/audio/processor.rs:8:22\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m:{debug, info, warn};\n  \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `TrackEvent`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/bot.rs","byte_start":414,"byte_end":424,"line_start":12,"line_end":12,"column_start":80,"column_end":90,"is_primary":true,"text":[{"text":"use songbird::events::{Event, EventContext, EventHandler as VoiceEventHandler, TrackEvent};","highlight_start":80,"highlight_end":90}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/bot.rs","byte_start":412,"byte_end":424,"line_start":12,"line_end":12,"column_start":78,"column_end":90,"is_primary":true,"text":[{"text":"use songbird::events::{Event, EventContext, EventHandler as VoiceEventHandler, TrackEvent};","highlight_start":78,"highlight_end":90}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `TrackEvent`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/bot.rs:12:80\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mler, TrackEvent};\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `CoreEvent`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/bot.rs","byte_start":442,"byte_end":451,"line_start":13,"line_end":13,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"use songbird::{CoreEvent, SerenityInit};","highlight_start":16,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/bot.rs","byte_start":442,"byte_end":453,"line_start":13,"line_end":13,"column_start":16,"column_end":27,"is_primary":true,"text":[{"text":"use songbird::{CoreEvent, SerenityInit};","highlight_start":16,"highlight_end":27}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/bot.rs","byte_start":441,"byte_end":442,"line_start":13,"line_end":13,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"use songbird::{CoreEvent, SerenityInit};","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/bot.rs","byte_start":465,"byte_end":466,"line_start":13,"line_end":13,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"use songbird::{CoreEvent, SerenityInit};","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `CoreEvent`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/bot.rs:13:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mird::{CoreEvent, Sere\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `GuildId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/commands/analyze.rs","byte_start":201,"byte_end":208,"line_start":5,"line_end":5,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    CreateInteractionResponseMessage, GuildId,","highlight_start":39,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":199,"byte_end":208,"line_start":5,"line_end":5,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"    CreateInteractionResponseMessage, GuildId,","highlight_start":37,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `GuildId`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:5:39\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mssage, GuildId,\n  \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `songbird::Songbird`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/commands/analyze.rs","byte_start":217,"byte_end":235,"line_start":7,"line_end":7,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"use songbird::Songbird;","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":213,"byte_end":237,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use songbird::Songbird;","highlight_start":1,"highlight_end":24},{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `songbird::Songbird`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:7:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use songbird::Songbird;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Result as SqliteResult`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/database.rs","byte_start":126,"byte_end":148,"line_start":5,"line_end":5,"column_start":28,"column_end":50,"is_primary":true,"text":[{"text":"use rusqlite::{Connection, Result as SqliteResult, params};","highlight_start":28,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/database.rs","byte_start":124,"byte_end":148,"line_start":5,"line_end":5,"column_start":26,"column_end":50,"is_primary":true,"text":[{"text":"use rusqlite::{Connection, Result as SqliteResult, params};","highlight_start":26,"highlight_end":50}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Result as SqliteResult`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/database.rs:5:28\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mn, Result as SqliteResult, p\u001b[1m\u001b[94m...\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AnalysisMode` and `GuildSettings`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/session.rs","byte_start":257,"byte_end":269,"line_start":8,"line_end":8,"column_start":23,"column_end":35,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":23,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":281,"byte_end":294,"line_start":8,"line_end":8,"column_start":47,"column_end":60,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":47,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":257,"byte_end":271,"line_start":8,"line_end":8,"column_start":23,"column_end":37,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":23,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/session.rs","byte_start":279,"byte_end":294,"line_start":8,"line_end":8,"column_start":45,"column_end":60,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":45,"highlight_end":60}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/session.rs","byte_start":256,"byte_end":257,"line_start":8,"line_end":8,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":22,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/session.rs","byte_start":294,"byte_end":295,"line_start":8,"line_end":8,"column_start":60,"column_end":61,"is_primary":true,"text":[{"text":"use crate::database::{AnalysisMode, Database, GuildSettings};","highlight_start":60,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `AnalysisMode` and `GuildSettings`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:8:23\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m::{AnalysisMode, Database, GuildSettings};\n  \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `interval`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/session.rs","byte_start":541,"byte_end":549,"line_start":17,"line_end":17,"column_start":19,"column_end":27,"is_primary":true,"text":[{"text":"use tokio::time::{interval, Duration};","highlight_start":19,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":541,"byte_end":551,"line_start":17,"line_end":17,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"use tokio::time::{interval, Duration};","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/session.rs","byte_start":540,"byte_end":541,"line_start":17,"line_end":17,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"use tokio::time::{interval, Duration};","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/session.rs","byte_start":559,"byte_end":560,"line_start":17,"line_end":17,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"use tokio::time::{interval, Duration};","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `interval`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:17:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mime::{interval, Durat\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `debug` and `error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/session.rs","byte_start":576,"byte_end":581,"line_start":18,"line_end":18,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":15,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":583,"byte_end":588,"line_start":18,"line_end":18,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":22,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":576,"byte_end":590,"line_start":18,"line_end":18,"column_start":15,"column_end":29,"is_primary":true,"text":[{"text":"use tracing::{debug, error, info, warn};","highlight_start":15,"highlight_end":29}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `debug` and `error`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:18:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mg::{debug, error, inf\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[33m^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_guild_cached` found for struct `GuildId` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":1162,"byte_end":1177,"line_start":34,"line_end":34,"column_start":26,"column_end":41,"is_primary":true,"text":[{"text":"    let guild = guild_id.to_guild_cached(&ctx.cache).ok_or(\"Guild not in cache\")?;","highlight_start":26,"highlight_end":41}],"label":"method not found in `GuildId`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-14923559728202032959.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `to_guild_cached` found for struct `GuildId` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:34:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mid.to_guild_cached(&c\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `GuildId`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-14923559728202032959.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"no field `cache` on type `&Context`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":1183,"byte_end":1188,"line_start":34,"line_end":34,"column_start":47,"column_end":52,"is_primary":true,"text":[{"text":"    let guild = guild_id.to_guild_cached(&ctx.cache).ok_or(\"Guild not in cache\")?;","highlight_start":47,"highlight_end":52}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `data`, `shard`, `shard_id`, `http`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-4630290110251094288.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `cache` on type `&Context`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:34:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0md(&ctx.cache).ok_or(\"\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `data`, `shard`, `shard_id`, `http`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-4630290110251094288.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2106,"byte_end":2107,"line_start":60,"line_end":60,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            m.content(format!(\"エラーが発生しました: {}\", e))","highlight_start":13,"highlight_end":14}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":2089,"byte_end":2090,"line_start":59,"line_end":59,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        command.edit_response(&ctx.http, |m| {","highlight_start":43,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2090,"byte_end":2090,"line_start":59,"line_end":59,"column_start":44,"column_end":44,"is_primary":true,"text":[{"text":"        command.edit_response(&ctx.http, |m| {","highlight_start":44,"highlight_end":44}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:59:43\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mommand.edit_response(&ctx.http, |m| {\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   m.content(format!(\"エラーが発生しました: {}\", e       \u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        command.edit_response(&ctx.http, |m\u001b[92m: /* Type */\u001b[0m| {\n   \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `(_, Result<_, _>)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2204,"byte_end":2205,"line_start":62,"line_end":62,"column_start":20,"column_end":21,"is_primary":false,"text":[{"text":"        return Err(e.into());","highlight_start":20,"highlight_end":21}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":1893,"byte_end":1907,"line_start":55,"line_end":55,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"    let (call, result) = manager.join(guild_id, voice_channel_id).await;","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this pattern a type, where the placeholders `_` are specified","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":1907,"byte_end":1907,"line_start":55,"line_end":55,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    let (call, result) = manager.join(guild_id, voice_channel_id).await;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": (_, Result<T, _>)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed for `(_, Result<_, _>)`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:55:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0met (call, result) = m\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   return Err(e.into());\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this pattern a type, where the placeholders `_` are specified\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let (call, result)\u001b[92m: (_, Result<T, _>)\u001b[0m = manager.join(guild_id, voice_channel_id).await;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m+++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `(_, ...)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2323,"byte_end":2327,"line_start":66,"line_end":66,"column_start":80,"column_end":84,"is_primary":false,"text":[{"text":"    let session = session_manager.create_session(guild_id, command.channel_id, call.clone())?;","highlight_start":80,"highlight_end":84}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":1893,"byte_end":1907,"line_start":55,"line_end":55,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"    let (call, result) = manager.join(guild_id, voice_channel_id).await;","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-6516318891635564077.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider giving this pattern a type, where the placeholders `_` are specified","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":1907,"byte_end":1907,"line_start":55,"line_end":55,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    let (call, result) = manager.join(guild_id, voice_channel_id).await;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": (_, Result<T, _>)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed for `(_, ...)`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:55:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0met (call, result) = manager.join(guild_id, voice_channel_id).await;\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0met session = session_manager.create_session(guild_id, command.channel_id, call.cl\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                                              \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/Users/osadayuushi/Desktop/Programming/DiscordBOT_surver/insight_bot_rust/target/debug/deps/insight_bot-d1ce2e4664f61188.long-type-6516318891635564077.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this pattern a type, where the placeholders `_` are specified\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let (call, result)\u001b[92m: (_, Result<T, _>)\u001b[0m = manager.join(guild_id, voice_channel_id).await;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m+++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2501,"byte_end":2564,"line_start":72,"line_end":74,"column_start":24,"column_end":16,"is_primary":true,"text":[{"text":"    let channel_name = voice_channel_id","highlight_start":24,"highlight_end":40},{"text":"        .to_channel(&ctx.http)","highlight_start":1,"highlight_end":31},{"text":"        .await?","highlight_start":1,"highlight_end":16}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:72:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let channel_name = voic\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________^\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .to_channel(&ctx.http)\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2718,"byte_end":2719,"line_start":80,"line_end":80,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        m.content(format!(","highlight_start":9,"highlight_end":10}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":2705,"byte_end":2706,"line_start":79,"line_end":79,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"    command.edit_response(&ctx.http, |m| {","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":2706,"byte_end":2706,"line_start":79,"line_end":79,"column_start":40,"column_end":40,"is_primary":true,"text":[{"text":"    command.edit_response(&ctx.http, |m| {","highlight_start":40,"highlight_end":40}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:79:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mommand.edit_response(&ctx.http, |m| {\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   m.content(format!(\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    command.edit_response(&ctx.http, |m\u001b[92m: /* Type */\u001b[0m| {\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":3991,"byte_end":3992,"line_start":114,"line_end":114,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        m.content(\"✅ 分析を終了しました。お疲れ様でした！\")","highlight_start":9,"highlight_end":10}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":3978,"byte_end":3979,"line_start":113,"line_end":113,"column_start":49,"column_end":50,"is_primary":true,"text":[{"text":"    command.channel_id.send_message(&ctx.http, |m| {","highlight_start":49,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":3979,"byte_end":3979,"line_start":113,"line_end":113,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"    command.channel_id.send_message(&ctx.http, |m| {","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:113:49\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mommand.channel_id.send_message(&ctx.http, |m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   m.content(\"✅ 分析を終了しました。お疲れ様でした！\")\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    command.channel_id.send_message(&ctx.http, |m\u001b[92m: /* Type */\u001b[0m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/commands/analyze.rs","byte_start":4935,"byte_end":4936,"line_start":140,"line_end":140,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            m.content(format!(\"⚠️ エラー: {}\", e))","highlight_start":13,"highlight_end":14}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/commands/analyze.rs","byte_start":4918,"byte_end":4919,"line_start":139,"line_end":139,"column_start":53,"column_end":54,"is_primary":true,"text":[{"text":"        command.channel_id.send_message(&ctx.http, |m| {","highlight_start":53,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/commands/analyze.rs","byte_start":4919,"byte_end":4919,"line_start":139,"line_end":139,"column_start":54,"column_end":54,"is_primary":true,"text":[{"text":"        command.channel_id.send_message(&ctx.http, |m| {","highlight_start":54,"highlight_end":54}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/commands/analyze.rs:139:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mommand.channel_id.send_message(&ctx.http, |m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m140\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   m.content(format!(\"⚠️ エラー: {}\", e))\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        command.channel_id.send_message(&ctx.http, |m\u001b[92m: /* Type */\u001b[0m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature `str_as_str`","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\nuse std::intrinsics; // error: use of unstable library feature `core_intrinsics`\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(core_intrinsics)]\n\nuse std::intrinsics; // ok!\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"src/commands/settings.rs","byte_start":2355,"byte_end":2361,"line_start":71,"line_end":71,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"    match subcommand.name.as_str() {","highlight_start":27,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"see issue #130366 <https://github.com/rust-lang/rust/issues/130366> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0658]\u001b[0m\u001b[1m: use of unstable library feature `str_as_str`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/commands/settings.rs:71:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0md.name.as_str() {\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: see issue #130366 <https://github.com/rust-lang/rust/issues/130366> for more information\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":5968,"byte_end":5969,"line_start":196,"line_end":196,"column_start":55,"column_end":56,"is_primary":false,"text":[{"text":"    let starter_msg = channel.send_message(&http, |m| m.content(&starter_text)).await?;","highlight_start":55,"highlight_end":56}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":5965,"byte_end":5966,"line_start":196,"line_end":196,"column_start":52,"column_end":53,"is_primary":true,"text":[{"text":"    let starter_msg = channel.send_message(&http, |m| m.content(&starter_text)).await?;","highlight_start":52,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":5966,"byte_end":5966,"line_start":196,"line_end":196,"column_start":53,"column_end":53,"is_primary":true,"text":[{"text":"    let starter_msg = channel.send_message(&http, |m| m.content(&starter_text)).await?;","highlight_start":53,"highlight_end":53}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:196:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mhttp, |m| m.content(\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let starter_msg = channel.send_message(&http, |m\u001b[92m: /* Type */\u001b[0m| m.content(&starter_text)).await?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":6306,"byte_end":6307,"line_start":206,"line_end":206,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        t.name(&thread_name).auto_archive_duration(60)","highlight_start":9,"highlight_end":10}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":6293,"byte_end":6294,"line_start":205,"line_end":205,"column_start":77,"column_end":78,"is_primary":true,"text":[{"text":"    let thread = channel.create_thread_from_message(&http, starter_msg.id, |t| {","highlight_start":77,"highlight_end":78}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":6294,"byte_end":6294,"line_start":205,"line_end":205,"column_start":78,"column_end":78,"is_primary":true,"text":[{"text":"    let thread = channel.create_thread_from_message(&http, starter_msg.id, |t| {","highlight_start":78,"highlight_end":78}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:205:77\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0met thread = channel.create_thread_from_message(&http, starter_msg.id, |t| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                           \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m206\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   t.name(&thread_name).auto_archive_duration(60)\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let thread = channel.create_thread_from_message(&http, starter_msg.id, |t\u001b[92m: /* Type */\u001b[0m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                              \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":6414,"byte_end":6415,"line_start":210,"line_end":210,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        m.content(format!(\"🔄 音声ファイルを分析中... (Mode: {})\", mode.as_str()))","highlight_start":9,"highlight_end":10}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":6401,"byte_end":6402,"line_start":209,"line_end":209,"column_start":33,"column_end":34,"is_primary":true,"text":[{"text":"    thread.send_message(&http, |m| {","highlight_start":33,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":6402,"byte_end":6402,"line_start":209,"line_end":209,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"    thread.send_message(&http, |m| {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:209:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mhread.send_message(&http, |m| {\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^\u001b[0m\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   m.content(format!(\"🔄 音声ファイルを分析中        \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    thread.send_message(&http, |m\u001b[92m: /* Type */\u001b[0m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":7502,"byte_end":7503,"line_start":243,"line_end":243,"column_start":40,"column_end":41,"is_primary":false,"text":[{"text":"        thread.send_message(&http, |m| m.content(format!(\"{}{}\", header, report))).await?;","highlight_start":40,"highlight_end":41}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":7499,"byte_end":7500,"line_start":243,"line_end":243,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"        thread.send_message(&http, |m| m.content(format!(\"{}{}\", header, report))).await?;","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":7500,"byte_end":7500,"line_start":243,"line_end":243,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"        thread.send_message(&http, |m| m.content(format!(\"{}{}\", header, report))).await?;","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:243:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m243\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mhttp, |m| m.content(\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m243\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        thread.send_message(&http, |m\u001b[92m: /* Type */\u001b[0m| m.content(format!(\"{}{}\", header, report))).await?;\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":7606,"byte_end":7607,"line_start":245,"line_end":245,"column_start":40,"column_end":41,"is_primary":false,"text":[{"text":"        thread.send_message(&http, |m| m.content(header)).await?;","highlight_start":40,"highlight_end":41}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":7603,"byte_end":7604,"line_start":245,"line_end":245,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"        thread.send_message(&http, |m| m.content(header)).await?;","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":7604,"byte_end":7604,"line_start":245,"line_end":245,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"        thread.send_message(&http, |m| m.content(header)).await?;","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:245:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m245\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mhttp, |m| m.content(\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m245\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        thread.send_message(&http, |m\u001b[92m: /* Type */\u001b[0m| m.content(header)).await?;\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/session.rs","byte_start":7790,"byte_end":7791,"line_start":248,"line_end":248,"column_start":44,"column_end":45,"is_primary":false,"text":[{"text":"            thread.send_message(&http, |m| m.content(&*chunk_str)).await?;","highlight_start":44,"highlight_end":45}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/session.rs","byte_start":7787,"byte_end":7788,"line_start":248,"line_end":248,"column_start":41,"column_end":42,"is_primary":true,"text":[{"text":"            thread.send_message(&http, |m| m.content(&*chunk_str)).await?;","highlight_start":41,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/session.rs","byte_start":7788,"byte_end":7788,"line_start":248,"line_end":248,"column_start":42,"column_end":42,"is_primary":true,"text":[{"text":"            thread.send_message(&http, |m| m.content(&*chunk_str)).await?;","highlight_start":42,"highlight_end":42}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/session.rs:248:41\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mhttp, |m| m.content(\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m248\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            thread.send_message(&http, |m\u001b[92m: /* Type */\u001b[0m| m.content(&*chunk_str)).await?;\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `ssrc`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/recorder.rs","byte_start":2463,"byte_end":2467,"line_start":94,"line_end":94,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"        for (ssrc, data) in &tick.speaking {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/audio/recorder.rs","byte_start":2463,"byte_end":2467,"line_start":94,"line_end":94,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"        for (ssrc, data) in &tick.speaking {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":"_ssrc","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `ssrc`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/audio/recorder.rs:94:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m  for (ssrc, data) in\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_ssrc`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `ogg_path`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/audio/recorder.rs","byte_start":5480,"byte_end":5488,"line_start":176,"line_end":176,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"        let ogg_path = self.temp_dir.join(format!(\"{}.ogg\", filename));","highlight_start":13,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/audio/recorder.rs","byte_start":5480,"byte_end":5488,"line_start":176,"line_end":176,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"        let ogg_path = self.temp_dir.join(format!(\"{}.ogg\", filename));","highlight_start":13,"highlight_end":21}],"label":null,"suggested_replacement":"_ogg_path","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `ogg_path`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/audio/recorder.rs:176:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m176\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m let ogg_path = self\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_ogg_path`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `ssrc`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/bot.rs","byte_start":3591,"byte_end":3595,"line_start":109,"line_end":109,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"            for (ssrc, data) in &tick.speaking {","highlight_start":18,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/bot.rs","byte_start":3591,"byte_end":3595,"line_start":109,"line_end":109,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"            for (ssrc, data) in &tick.speaking {","highlight_start":18,"highlight_end":22}],"label":null,"suggested_replacement":"_ssrc","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `ssrc`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bot.rs:109:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m  for (ssrc, data) i\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_ssrc`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `decoded`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/bot.rs","byte_start":3710,"byte_end":3717,"line_start":111,"line_end":111,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                if let Some(decoded) = &data.decoded_voice {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/bot.rs","byte_start":3710,"byte_end":3717,"line_start":111,"line_end":111,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                if let Some(decoded) = &data.decoded_voice {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":"_decoded","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `decoded`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bot.rs:111:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mSome(decoded) = &dat\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_decoded`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `packet`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/bot.rs","byte_start":4345,"byte_end":4351,"line_start":121,"line_end":121,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"                if let Some(packet) = &data.packet {","highlight_start":29,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/bot.rs","byte_start":4345,"byte_end":4351,"line_start":121,"line_end":121,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"                if let Some(packet) = &data.packet {","highlight_start":29,"highlight_end":35}],"label":null,"suggested_replacement":"_packet","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `packet`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bot.rs:121:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mSome(packet) = &data\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_packet`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 20 previous errors; 18 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 20 previous errors; 18 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0425, E0433, E0599, E0609, E0658.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0282, E0425, E0433, E0599, E0609, E0658.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}
